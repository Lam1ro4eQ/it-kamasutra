Компонента - функция которая принимает пропсы и возвращает jsx разметку
Экшнкрейтер - функция которая возвращает экшен, она может принимать параметры. Экшен это объект у которого есть как минимум type
Интерфейс функции - это то как мы взаимодействуем с функцией (параметры, имя функции, что получаем)

Редьюсер - функция, принимает стейт и инструкцию(+данные по необходимости), которая говорит что нужно сделать со стейтом (switch a.type case)

Редакс: чтобы не пробрасывать пропсы, хранение и управление состоянием, на паттерне флакс архитектуры

Продаем реакт - реакт это библиотека(должны будем доустанавливать модули с помощью npm или yarn) Удобство в том что мы не привязываемся к фраемворку, более гибкая разработка + реакт диктует функциональное программирование т.е. разделение по блокам, блоки можно переиспользовать в разных местах. Реакт позволяет быстро отрисовывать с помощью виртуального дом дерева. есть ньансы Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики (memo) - помогает проверять приходимые пропсы, если они старые и не менялись то перерисовки не будет. JSX - верстка и js вместе. spa, отрисовывается один раз страница, при изменениях перерисовка отдельных компонент

Пропсы - это объект, свойствами которого будут атрибуты, которые мы передаём.
Props - это параметр нашей функции, это объект, который приходит в нашу функцию-компоненту. Компонента может использовать эти данные для отображения.

Замыкание - способность функции запоминать тот объект лексического окружения в котором она создана (для объекта локальный скоуп не создается)

Недлстатки РЕАКТ - spa, отрисовывается один раз страница, при изменениях перерисовка отдельных компонент, НО первая загрузка оень долгая
					
mapStateToProps  -  функция которая принимает стейт(всего приложения) 

DOM дерево - объект, который содержит свойства(теги html) и методы(js)

Компоненты(Функциональные и Классовые)

Жизненный цикл компоненты - рождение, изменение(обновление), смерть

Методы жизненного цикла - 

Обновлвение UI - рендер -> сравнение двух вирт домов -> фиксация -> изменение в реальном доме

Ререндер происходит в 3 случаях - 1) поменялось локальное состояние useState 2) пришли новые пропсы или поменялись 3) Перерисовался родительский компонента + в ручную форсАпдейт

Идемпатентность Детарминированость  -  предсказуемость, отправляем одни и те же данные и получаем один и тот же результат
Идемпотентность !== Детерминированность.

Классы нужны чтобы создавать однтипные компоненты на основе этих классов

1) Идемпотентность - Свойство которое гарантирует, что при многократном вызове функции состояние будет изменено только единожды. Для примера можно посмотреть на работу DELETE в SQL. DELETE это идемпотентная операция. Например если в базе данных удалить с помощью DELETE ну к примеру пользователя, то при повторной попытке запуска такой функции с той же сигнатурой мы получаем что то вроде "This user already deleted". То есть мы 10 раз делаем попытку удаления пользователя, но состояние базы а именно ее изменение происходит единожды, остальные вызовы просто логируют, что операция уже была проведена, но ничего в самой базе не делают.

2) Детерминированность - Обрабатываем только то что получили в сигнатуре (аргументы).  При многократном вызове такой функции с теми же параметрами мы получаем один и тот же результат как и должно быть, но мы не защищены от многократного изменения состояния. К примеру если мы попробуем добавить в нашу базу данных пользователя и никак не защитимся от дубликатов, то при вызове такой детерминированной функции 10 раз, мы получим 10 дубликатов пользователя в базе.

Итог: Детерминированность НЕ обеспечивает идемпотентность и на оборот. Идемпотентность НЕ обеспечивает детерминированность. Мы вполне свободно можем писать грязные функции с любым из этих свойств, и комбинировать их между собой. Это два разных и нечем не связанных свойства функций которые предлагают разные гарантии при реализации. 


" ИЛИ    -    ||  "  запинается на правде    ,
" И   -   &&  "    запинается на лжи...

Императивный стиль - набор команд который непосредственно выполняется (как делать)
Декларативный стиль - что хотим получить  (что делать что хотим получить)


запускается скрипт в html, индекс.tsx, запускает все компоненты(функции), jsx транспилируется бейблом в js, виртуал дом создается, создается дом на основе виртуал дома

Когда чтото делает пользователь - меняет стейт, запускаются функции (компоненты), вернется новая разметка, рендер, новая версия виртуал дома, сравнение со старым,  

useSelector - забрать данные
useDispatch - 

setState() в реакте, диспатч в редаксе - функция которая начинает перерисовку

setState - асинхранная ф-ция

хок - функция, принимает компоненту и возвращает компоненту. Возвращаемую наделяет определенными функциями









Для того чтобы удобней видеть rerender наших компонент, можете поставить расширение в браузер: Redux Dev Tools. После установки, открываем наше приложение в браузере, нажимаем f12 (открывается консоль разработчика), переходим во вкладку Profiler. В правом верхнем углу нажимаем на шестерёнку, и ставим галочку в Highlight updates when components render (End) или Выделение обновлений при рендеринге компонентов (Ru).


три принципа redux 1) единственный источник правды - стор, который меняется и всегда содержит актуальные данные
2) состояние только для чтения, нельзя менять напрямую. Только с помощью action
3) изменения делаются только при помощи чистых функций. при одних и тех же данных результат одинаковый и не меняется

Движение данных в редакс - вызываем функцию диспатч из стора и передаем ей action -> redux вызывает переданный в него reduсer, стор отправляет в редбюсер два аргумента 1) текущее состояние, объект 2) action  -> 
редьюсер возвращает новый объект с новым состоянием  ->  редакс стор сохраняет этот объект

Экшены(Actions) — Объект который описывает действия (единственная возможность изменить store) ЧТО Я ХОЧУ ИЗМЕНИТЬ?
Экшенкрейтер(ActionCreator) — функция принимающая на вход изменяемый аргумент экшена
Редьюсеры — (Reducers) КАК Я ХОЧУ ИЗМЕНИТЬ State
Стор (Store) — это объект, который соединяет эти части вместе.
Dispatch — именно этот метод позволяет отправить действие диспетчеру и изменить состояние приложения.

Санка - функция, обязательно принимает диспатч. Задача санки сделать асинхронную работу, попросить дать данные, например от апи. Когда она их получит отправить в бизнес, чтобы зафиксировать (в рекакс через диспатч)