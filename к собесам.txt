Компонента - функция которая принимает пропсы и возвращает jsx разметку
Экшнкрейтер - функция которая возвращает экшен, она может принимать параметры. Экшен это объект у которого есть как минимум type
Интерфейс функции - это то как мы взаимодействуем с функцией (параметры, имя функции, что получаем)

Редьюсер - функция, принимает стейт и инструкцию(+данные по необходимости), которая говорит что нужно сделать со стейтом (switch a.type case)

Редакс: чтобы не пробрасывать пропсы, хранение и управление состоянием, на паттерне флакс архитектуры

Продаем реакт - реакт это библиотека(должны будем доустанавливать модули с помощью npm или yarn) Удобство в том что мы не привязываемся к фраемворку, более гибкая разработка + реакт диктует функциональное программирование т.е. разделение по блокам, блоки можно переиспользовать в разных местах. Реакт позволяет быстро отрисовывать с помощью виртуального дом дерева. есть ньансы Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики (memo) - помогает проверять приходимые пропсы, если они старые и не менялись то перерисовки не будет. JSX - верстка и js вместе. spa, отрисовывается один раз страница, при изменениях перерисовка отдельных компонент

Замыкание - способность функции запоминать тот объект лексического окружения в котором она создана (для объекта локальный скоуп не создается)

Недлстатки РЕАКТ - spa, отрисовывается один раз страница, при изменениях перерисовка отдельных компонент, НО первая загрузка оень долгая
					
mapStateToProps  -  функция которая принимает стейт(всего приложения) 

DOM дерево - объект, который содержит свойства(теги html) и методы(js)

Компоненты(Функциональные и Классовые)

Жизненный цикл компоненты - рождение, изменение(обновление), смерть

Методы жизненного цикла - 

Обновлвение UI - рендер -> сравнение двух вирт домов -> фиксация -> изменение в реальном доме

Ререндер происходит в 3 случаях - 1) поменялось локальное состояние useState 2) пришли новые пропсы или поменялись 3) Перерисовался родительский компонента + в ручную форсАпдейт

Идемпатентность Детарминированость  -  предсказуемость, отправляем одни и те же данные и получаем один и тот же результат
Идемпотентность !== Детерминированность.

Классы нужны чтобы создавать однтипные компоненты на основе этих классов

1) Идемпотентность - Свойство которое гарантирует, что при многократном вызове функции состояние будет изменено только единожды. Для примера можно посмотреть на работу DELETE в SQL. DELETE это идемпотентная операция. Например если в базе данных удалить с помощью DELETE ну к примеру пользователя, то при повторной попытке запуска такой функции с той же сигнатурой мы получаем что то вроде "This user already deleted". То есть мы 10 раз делаем попытку удаления пользователя, но состояние базы а именно ее изменение происходит единожды, остальные вызовы просто логируют, что операция уже была проведена, но ничего в самой базе не делают.

2) Детерминированность - Обрабатываем только то что получили в сигнатуре (аргументы).  При многократном вызове такой функции с теми же параметрами мы получаем один и тот же результат как и должно быть, но мы не защищены от многократного изменения состояния. К примеру если мы попробуем добавить в нашу базу данных пользователя и никак не защитимся от дубликатов, то при вызове такой детерминированной функции 10 раз, мы получим 10 дубликатов пользователя в базе.

Итог: Детерминированность НЕ обеспечивает идемпотентность и на оборот. Идемпотентность НЕ обеспечивает детерминированность. Мы вполне свободно можем писать грязные функции с любым из этих свойств, и комбинировать их между собой. Это два разных и нечем не связанных свойства функций которые предлагают разные гарантии при реализации. 


" ИЛИ    -    ||  "  запинается на правде    ,
" И   -   &&  "    запинается на лжи...

Императивный стиль - набор команд который непосредственно выполняется (как делать)
Декларативный стиль - что хотим получить  (что делать что хотим получить)


запускается скрипт в html, индекс.tsx, запускает все компоненты(функции), jsx транспилируется бейблом в js, виртуал дом создается, создается дом на основе виртуал дома

Когда чтото делает пользователь - меняет стейт, запускаются функции (компоненты), вернется новая разметка, рендер, новая версия виртуал дома, сравнение со старым,  

setState() в реакте, диспатч в редаксе - функция которая начинает перерисовку
